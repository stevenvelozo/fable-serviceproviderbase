# Initialization Patterns

The `FableServiceProviderBase` constructor supports three initialization modes. The same base class handles all three -- it detects whether a Fable instance was passed in and adjusts behavior accordingly.

## Pattern 1: With Fable

The standard pattern for application services. Pass a Fable instance as the first argument.

```javascript
const libFableServiceProviderBase = require('fable-serviceproviderbase');

class MyService extends libFableServiceProviderBase
{
    constructor(pFable, pOptions, pServiceHash)
    {
        super(pFable, pOptions, pServiceHash);
        this.serviceType = 'MyService';
    }
}

const libFable = require('fable');
let _Fable = new libFable();

let tmpService = new MyService(_Fable, { ConnectionTimeout: 5000 }, 'Primary');
```

After construction:

| Property | Value |
|----------|-------|
| `this.fable` | The Fable instance |
| `this.log` | `fable.Logging` |
| `this.services` | `fable.services` |
| `this.servicesMap` | `fable.servicesMap` |
| `this.UUID` | Generated by Fable's UUID service |
| `this.options` | `{ ConnectionTimeout: 5000 }` |
| `this.Hash` | `'Primary'` |

## Pattern 2: Pre-initialization (Core Services)

Some services need to exist before Fable is fully initialized -- for example, logging or settings services that Fable itself depends on. These are constructed without a Fable instance and connected later.

```javascript
const libFableServiceProviderBase = require('fable-serviceproviderbase');

class MyCoreService extends libFableServiceProviderBase.CoreServiceProviderBase
{
    constructor(pOptions, pServiceHash)
    {
        super(pOptions, pServiceHash);
        this.serviceType = 'MyCoreService';
    }

    earlyBehavior()
    {
        // This works even before Fable is initialized
        console.log(`Core service ${this.Hash} is ready`);
    }
}

// Create the service early
let tmpCore = new MyCoreService({ SomeOption: true }, 'CoreInstance-1');
tmpCore.earlyBehavior();

// Later, when Fable is ready, connect it
let _Fable = new libFable();
_Fable.serviceManager.connectPreinitServiceProviderInstance(tmpCore);

// Now tmpCore.fable, tmpCore.log, tmpCore.services are all available
```

After construction (before `connectFable`):

| Property | Value |
|----------|-------|
| `this.fable` | `false` |
| `this.log` | `undefined` |
| `this.services` | `undefined` |
| `this.UUID` | `'CORE-SVC-XXXXX'` (random 5-digit number) |
| `this.options` | `{ SomeOption: true }` |
| `this.Hash` | `'CoreInstance-1'` |

After `connectFable` or `connectPreinitServiceProviderInstance`:

| Property | Value |
|----------|-------|
| `this.fable` | The Fable instance |
| `this.log` | `fable.Logging` |
| `this.services` | `fable.services` |

Note: `CoreServiceProviderBase` is an alias for `FableServiceProviderBase`. They are the same class. The alias exists for readability -- it signals that the service is designed for pre-initialization use.

## Pattern 3: Standalone (No Fable)

For testing or non-Fable contexts, services can be constructed with just an options object:

```javascript
let tmpService = new MyService({ Setting: 'value' });
```

After construction:

| Property | Value |
|----------|-------|
| `this.fable` | `false` |
| `this.log` | `undefined` |
| `this.UUID` | `'CORE-SVC-XXXXX'` (random) |
| `this.options` | `{ Setting: 'value' }` |
| `this.Hash` | Same as UUID |

The service works but has no access to Fable's logging, configuration, or other services. You can call `connectFable(fableInstance)` later to wire everything up.

## Constructor Parameter Detection

The constructor uses a simple heuristic: if the first parameter is an object with an `isFable` property set to `true`, it treats it as a Fable instance. Otherwise, the first parameter is treated as the options object.

```
new Service(fable, options, hash)   →  fable.isFable is true  →  Pattern 1
new Service(options, hash)          →  options.isFable is falsy →  Pattern 2/3
new Service()                       →  no arguments             →  Pattern 3
```

The `pServiceHash` parameter sets `this.Hash`. If omitted, the hash defaults to the UUID. When no Fable is present, if the second parameter is a string, it is used as the hash.
